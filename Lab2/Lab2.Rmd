---
title: "Quantitative Genomics and Genetics 2018"
subtitle: "Computer Lab 2"
author: "Scott Kulm"
date: "2/5/2018"
output: html_document
---

-- R Markdown   
-- Functions   
-- For loops   
-- If/else statements   
-- Vector and Matrix calculation   

--------------------------------------------------------------------------------------

### 0. Logistics
- If you have any questions about R or lecture let me know now, or send an email (sdk2004@med.cornell.edu), will also respond to Piazza but I get easily lost in all of the posts
- Make this time the best possible, let me know how I can improve/what you want: "https://docs.google.com/forms/d/e/1FAIpQLSf6eXRBihxWy5-1LiGqX4pabRsdlgP_Qoz124uGxfv2kIpLKQ/viewform?usp=sf_link"
- Hopefully everyone is on CMS and Piazza, if not let me know


### 1. R Markdown

#### Standard text formating
- *italics*
- **bold**

#### Latex equations
- conditional probability: $Pr(X_1|X_2) = \frac{Pr(X_1 \cap X_2)}{Pr(X_2)}$
- matrix: $$A_{m,n} =
 \begin{pmatrix}
  a_{1,1} & a_{1,2} & \cdots & a_{1,n} \\
  a_{2,1} & a_{2,2} & \cdots & a_{2,n} \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  a_{m,1} & a_{m,2} & \cdots & a_{m,n}
 \end{pmatrix}$$

#### Code chunks
```{r}
example.vector1 <- 1:10
mean(example.vector1)
```

Code options   

- `include = FALSE` prevents code and results from appearing in the finished file. R Markdown still runs the code in the chunk, and the results can be used by other chunks.   
- `echo = FALSE` prevents code, but not the results from appearing in the finished file. This is a useful way to embed figures.   

For more information on using R Markdown: http://rmarkdown.rstudio.com/lesson-1.html   

--------------------------------------------------------------------------------------

### 2. Functions

- We learned that a function is something that takes in an input and gives you an output.

- Functions require "( )", whereas data objects will have "[ ]"

- R has many built in functions for commonly used methods in statistics.

```{r, comment=NA}
# Examples of built in functions 
example.vector1 <- c(5,2,3,7,1,1,2,9,9)
# a function that calculates the mean
mean(example.vector1) 
# a function to index specific values
which(example.vector1==3)
```

- We can also build custom functions. 

```{r, comment=NA}
# the syntax for declaring functions, note the {} after function()
log10_add <- function(input1,input2){   # all the inputs are specified within the ( )
  cat("This is a custom function \n")   
  cat("The inputs are = ",input1,input2,"\n")  # showing you the inputs 
  output <- log10(input1) + log10(input2)       # creating an output within the function
  cat("The output is = ",output,"\n")          # print the output
  return(output)                               # return specifies the output
}
# Now we can call our custom functions like this
log10_add(100,1000)
# Note that the variable output is not created in our workspace 
ls()
# in order to save the result of a function to a variable we have to assign it to a variable
test.output <- log10_add(100,1000)
test.output
```

**Question 1**

- Can you guess what is going to happen?

```{r, comment = NA, eval = FALSE}
x <- 11
test_function <- function(y){
  output <- x + y
  return(output)
}
test_function(2) 
```

- There are many ways to set your function arguments

```{r, comment = NA, eval = FALSE}
test_function <- function(y=myInput){
  output <- x + y
  return(output)
}
myInput <- 3
test_function() #the default function argument is myInput
test_function(y=5) #we now overrtide the default to be 5
```

- Short intro to scope: what happens in the function, stays in the function
- Which means any object you want to use in the function should be set as an argument

```{r, comment = NA, eval = FALSE}
output <- 5

test_function <- function(y=myInput){
  output <- x + y
  cat("The output is ",output,"\n")
  return(output)
}

myOuput<-test_function(4)
print(myOuput)
print(output)
```

**Question 2**

- Can you guess what is going to happen?

```{r, comment = NA, eval = FALSE}
test_function <- function(myInput=5){
  output <- 5 + myInput
  return(output)
}
test_function(m=10) 
```

#### Installing and Loading packages

- We can also use functions by installing published packages if somebody else did the hard work for us.

- We can install packages that are published on CRAN by using install.packages().

```{r}
# install.packages("ggplot2")
```

- Other packages can be install following the prompts from GitHub or Bioconductor: https://github.com/brooke-watson/BRRR

- Once the installation is complete, we to load the package into your current R session in order to use it.

```{r}
library(ggplot2)
require(ggplot2)
```

- Now we can use the functions from ggplot2
- ggplot is a really great function that I promise we'll get back to soon
- For now just note there are also base R functions that form plots, but ggplot looks much better

```{r}
x <- seq(1,10)
y <- sample(1:100,10,replace=T)
ggplot(data.frame(x,y), aes(x,y)) + geom_point()
ggplot(data.frame(x,y), aes(x,y,color="red")) + geom_point() +labs(title="This is a title",subtitle="This is a subtitle")
plot(x,y)
```

--------------------------------------------------------------------------------------

### 3. for loops

- For loops are mainly used in cases where you want to do a task multiple times.
- Note the notation of R-command (parameters) { what to do} is the same as the function

```{r}
N <- 3
for ( i in 1:N ){
    cat("Processing loop number = ",i,"\n")
}
```

- You can also create a loop within a loop

```{r}
for ( outer in 1:3 ){
    cat("Processing Outer Loop #", outer, "\n")
  for ( inner in 1:2 ){
      cat("Processing |_ Inner Loop #", inner, "\n")
    }
}
```

**Question2**

- What is the final value of N ?

```{r, eval = FALSE}
N <- 3
for( i in 1:N){
  cat("Processing loop = ", i, "\n")
  N <- N + 1
}
print(N)
```


--------------------------------------------------------------------------------------

### 4. If / else statements 

- By using if and else statements you can insert condition specific executions in your script

- The code inside an if statement will only be executed when the condition is TRUE

```{r, comment = NA, eval = FALSE}
if (condition) {
  do stuff
} else {
  do stuff
}
# OR you can add more levels by using else if
if(condition){
  do stuff
} else if (condition 2){
  do stuf
} else {
  do stuff
}
```

- Here is a simple example

```{r, comment = NA}
example.vector <- seq(1,25,by= 2)
# Loop over individual elements in example.vector
for( i in example.vector){
    if( i < 10 ){
        cat(i, "is smaller than 10 \n") 
    } else if ( 10 <= i & i <= 20){
        cat(i, "is in the interval [10,20] \n")
    } else {
        cat(i, "is larger than 20 \n")
    }
}
```


--------------------------------------------------------------------------------------

### 5. Vector and Matrix calculations

- If you want to modify each element of a vector by a scalar value you can use the math operations that we have learned last week.

```{r}
example.vector1
2 * example.vector1
1 + example.vector1
example.vector1 ^2
```

- If you are interested in the dot product of two vectors you have to use a special operator

```{r}
example.vector1 %*% example.vector1
```

- The same applies for matrices 

```{r}
example.matrix1 <- matrix(c(1,1,1,2,2,2), nrow = 2, ncol = 3, byrow= TRUE)
example.matrix1
2 * example.matrix1
example.matrix1 ^ 2
example.matrix1 - 1
```

- Here is how you can do matrix calculations

```{r, comment = NA}
# t() is transposing the matrix
example.matrix1 %*% t(example.matrix1)
# Note the dimensions 2 x 3 %*% 3 x 2  = 2 x 2 
```

- Here are some useful functions that can be used in matrix calculations 

```{r, comment = NA}
# creating a diagonal matrix with the first input as values on the diagonal
diag(2,nrow = 3)
# calculating the inverse of a matrix
A <- matrix(c(2,-3,1,0.5),nrow = 2)
solve(A)
# we can check this by 
A %*% solve(A) # which results in an identity matrix 
```

--------------------------------------------------------------------------------------

### Problem

You have recetly inherited a collection of trick coins, each has a different probability of coming up tails.  Looking to make some money you stand on the sidewalk and ask people who pass by to take the bet: If in two coin flips it lands tails twice I win, if the second coin flip is heads then you win.  Assuming you use the same coin for both flips, what is the probability of tails that will allow you to win this bet more than half the time?

Let's answer with a simulation:
```{r, comment = NA}
numberDoubleFlips <- 1000
firstFlip <- rbinom(n = numberDoubleFlips, size = 1,prob = 0.5)
secondFlip <- rbinom(n = numberDoubleFlips, size = 1,prob = 0.5)
sum(firstFlip==1 & secondFlip==1)/numberDoubleFlips #tails
sum(secondFlip==0)/numberDoubleFlips #heads
```

Second Part: Your victim is starting to get wise.  If you start using a nearly fair coin (prob=0.55) on the first flip, what must be the probability of the second coin to again assure you'll make some money.

Please submit your code showing the simulation for the first part on CMS.  If you are new to R I would encourage you to also give the second part a try if you have time.  If you are looking for a challenge then create a ggplot of the percent winnings versus the probability of getting tails.